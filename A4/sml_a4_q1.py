# -*- coding: utf-8 -*-
"""SMLA4_Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sGdHWhzrbUPsuR2kKbjDP7m2LzVMx_IP
"""

from google.colab import drive
drive.mount('/content/gdrive')

!pip install -q idx2numpy

import pandas as pd
import idx2numpy
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
from sklearn.tree import DecisionTreeRegressor
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, confusion_matrix
from tqdm import tqdm

"""#Question 1

### Gradient Boosting Classifier
"""

#loading the dataset
X_train = idx2numpy.convert_from_file('/content/gdrive/MyDrive/ML datasets/SML/mnist/train-images.idx3-ubyte')
Y_train = idx2numpy.convert_from_file('/content/gdrive/MyDrive/ML datasets/SML/mnist/train-labels.idx1-ubyte')
X_test = idx2numpy.convert_from_file('/content/gdrive/MyDrive/ML datasets/SML/mnist/t10k-images.idx3-ubyte')
Y_test = idx2numpy.convert_from_file('/content/gdrive/MyDrive/ML datasets/SML/mnist/t10k-labels.idx1-ubyte')

X_train.shape

#Reshaping the data from 3d to 2d
X_train = X_train.reshape(len(X_train),X_train.shape[1]*X_train.shape[2])
X_test = X_test.reshape(len(X_test),X_test.shape[1]*X_test.shape[2])
accuracy_list = list()

X_train.shape

#hot encoding the target 
y_encoding = pd.get_dummies(Y_train).to_numpy()

#function to calculate log(odds)
def log_odds(Y):
  lo = np.log(np.count_nonzero(Y == 1) / np.count_nonzero(Y == 0))
  return lo

#function to calculate probability for log(odds)
def get_prob(odds):
  e = np.exp(odds)
  p = e / (1+e)
  return p

learning_rate = 0.1
n_iter = 5
max_depth = 1
x = X_train
n = x.shape[0]
m = X_test.shape[0]

#grdientboost classifier
def gradient(y):
  F0 = log_odds(y)
  Fm = np.full(n, F0)
  trees = []
  for _ in range(n_iter-1):
    residual = y - get_prob(Fm)
    tree = DecisionTreeRegressor(max_depth=max_depth)
    tree.fit(x, residual)
    pred = tree.predict(x)
    Fm += learning_rate * pred
    trees.append(tree)

  # Prediction
  y_odds = np.full(m , F0)
  for i in range(4):
    y_odds += learning_rate * trees[i].predict(X_test)
 
  y_prob = get_prob(y_odds)
  return y_prob

#function to predict y_pred
def predict():
  prediction = []
  for i in tqdm(range(10)):
    g = gradient(y_encoding[:,i])
    prediction.append(g)
  
  prediction = np.array(prediction).T
  y_pred = []
  for i in prediction:
    y_pred.append(np.argmax(i))

  return y_pred

y_pred = predict()

accuracy = accuracy_score(Y_test,y_pred)
print("Final testing accuracy :",accuracy)